#!/usr/bin/python
#coding: UTF-8
"""

题目：海滩上有一堆桃子，五只猴子来分。第一只猴子把这堆桃子平均分为五份，多了一个，这只猴子把多的一个扔入海中，拿走了一份。第二只猴子把剩下的桃子又平均分成五份，又多了一个，它同样把多的一个扔入海中，拿走了一份，第三、第四、第五只猴子都是这样做的，问海滩上原来最少有多少个桃子？
    求最少的桃子，加入最后一只猴子拿走一个桃子

程序分析：
设开始有x个桃子,我们把x写成(x+4)－4．

第一个猴子来了,吃掉1个,还有桃子

(x+4)－4－1=(x+4)－5,

这时恰好可分成5份,每份的桃子数为

[(x+4）-5]/5=(x+4)/5－1

(x+4)/5必须为整数,所以（x+4）是5的倍数,

第一个猴子藏掉一份后,剩下的桃子为：

（4/5)×[(x+4)-5]＝(4/5)×(x+4)－4

同样,第二个猴子来了,一吃一藏之后,剩下的桃子数为

(4/5)×[(4/5)×(x+4)－5]

由于(4/5)×(4/5)×(x+4)是整数,故（x+4）应是5×5＝25的倍数,

如此一来五个猴子一吃一藏,恰好剩下

(4/5)×(4/5)× (4/5)×(4/5) ×(4/5) ×(x+4)-5个桃子,

故(x+4)必须是5×5×5×5×5的倍数,

即x+4=5^5

所以：x=3125-4=3121

即开始最少有3121个桃子．

"""
#逆向思维解决此问题
q = 0  #控制猴子数目，在本题中与分桃子次数相等
x = 0 
j = 1  #假设第5只猴子分完后剩余4份中的一份为m个，则此时剩余为4m个  ，第5只猴子分桃子时总数为 4m +m +1 
    # 及是理解为m*(5/4)+1，但是写程序时不能这样写,应写为m*5/4+1 """
     #此时 假设第五只猴子分得一个即:  m=j=1
  
while q < 5:     
     x = 4 * j   # 第五只猴子分完后剩余桃子总数
     for i in range( 0 , 5 ):   #5次循环迭代出桃子总数
         if( x % 4 != 0):    #当每次桃子分完并拿走自己的部分时剩余的不是4的倍数，则证明j值小了
             q =0
             break      #跳出第一个循环重新进入初始化剩余桃子数
         else:
             q +=1    #q表示第倒数q只猴子
         x = x * 5 / 4 + 1      # i为多少，表示(5-i)只猴子开始分桃子数，没有拿走自己的也没有丢时的数目

     j += 1          #当初始化桃子剩余数不满足条件时则，为增加初始化桃子做准备，在上面的x=4*j
     
print x
